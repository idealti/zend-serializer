{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-serializer zend-serializer provides an adapter-based interface for generating and recovering from storable representations of PHP types. File issues at https://github.com/zendframework/zend-serializer/issues Documentation is at https://docs.zendframework.com/zend-serializer/","title":"zend-serializer"},{"location":"#zend-serializer","text":"zend-serializer provides an adapter-based interface for generating and recovering from storable representations of PHP types. File issues at https://github.com/zendframework/zend-serializer/issues Documentation is at https://docs.zendframework.com/zend-serializer/","title":"zend-serializer"},{"location":"adapter/","text":"Adapters zend-serializer adapters handle serialization to and deserialization from specific representations. Each adapter has its own strengths. In some cases, not every PHP datatype (e.g., objects) can be converted to a string representation. In most such cases, the type will be converted to a similar type that is serializable. As an example, PHP objects will often be cast to arrays. If this fails, a Zend\\Serializer\\Exception\\ExceptionInterface will be thrown. The PhpSerialize Adapter The Zend\\Serializer\\Adapter\\PhpSerialize adapter uses the built-in serialize() / unserialize() functions, and is a good default adapter choice. Available options include: Option Data Type Default Value Description unserialize_class_whitelist array or bool true The allowed classes for unserialize(), see unserialize() for more information. Only available on PHP 7.0 or higher. The IgBinary Adapter Igbinary was originally released by Sulake Dynamoid Oy and since 2011-03-14 moved to PECL and maintained by Pierre Joye. It's a drop-in replacement for the standard PHP serializer. Instead of using a costly textual representation, igbinary stores PHP data structures in a compact binary form. Savings are significant when using memcached or similar memory based storages for serialized data. You need the igbinary PHP extension installed on your system in order to use this adapter. There are no configurable options for this adapter. The Wddx Adapter WDDX (Web Distributed Data eXchange) is a programming-language-, platform-, and transport-neutral data interchange mechanism for passing data between different environments and different computers. The adapter uses the wddx PHP functions. Please read the PHP manual to determine how you may enable them in your installation. Additionally, the SimpleXML extension is used to check if a returned NULL value from wddx_unserialize() is based on a serialized NULL or on invalid data. Available options include: Option Data Type Default Value Description comment string An optional comment that appears in the packet header. The Json Adapter The JSON adapter provides a bridge to the zend-json component. Available options include: Option Data Type Default Value cycle_check boolean false object_decode_type Zend\\Json\\Json::TYPE_* Zend\\Json\\Json::TYPE_ARRAY enable_json_expr_finder boolean false The PythonPickle Adapter This adapter converts PHP types to a Python Pickle string representation. With it, you can read the serialized data with Python and read Pickled data from Python with PHP. This adapter requires the zend-math component: $ composer require zendframework/zend-math Available options include: Option Data Type Default Value Description protocol integer (0/1/2/3) 0 The Pickle protocol version used on serialize Datatype merging (PHP to Python Pickle) PHP Type Python Pickle Type NULL None boolean boolean integer integer float float string string array list list array map dictionary object dictionary Datatype merging (Python Pickle to PHP) Python Pickle Type PHP Type None NULL boolean boolean integer integer long integer , float , string , or Zend\\Serializer\\Exception\\ExceptionInterface float float string string bytes string unicode string string UTF-8 list array list tuple array list dictionary array map All other types Zend\\Serializer\\Exception\\ExceptionInterface The PhpCode Adapter The Zend\\Serializer\\Adapter\\PhpCode adapter generates a parsable PHP code representation using var_export() . To restore, the data will be executed using eval . There are no configuration options for this adapter. Warning: Unserializing objects Objects will be serialized using the __set_state magic method. If the class doesn't implement this method, a fatal error will occur during execution. Warning: Uses eval() The PhpCode adapter utilizes eval() to unserialize. This introduces both a performance and potential security issue as a new process will be executed. Typically, you should use the PhpSerialize adapter unless you require human-readability of the serialized data.","title":"Adapters"},{"location":"adapter/#adapters","text":"zend-serializer adapters handle serialization to and deserialization from specific representations. Each adapter has its own strengths. In some cases, not every PHP datatype (e.g., objects) can be converted to a string representation. In most such cases, the type will be converted to a similar type that is serializable. As an example, PHP objects will often be cast to arrays. If this fails, a Zend\\Serializer\\Exception\\ExceptionInterface will be thrown.","title":"Adapters"},{"location":"adapter/#the-phpserialize-adapter","text":"The Zend\\Serializer\\Adapter\\PhpSerialize adapter uses the built-in serialize() / unserialize() functions, and is a good default adapter choice. Available options include: Option Data Type Default Value Description unserialize_class_whitelist array or bool true The allowed classes for unserialize(), see unserialize() for more information. Only available on PHP 7.0 or higher.","title":"The PhpSerialize Adapter"},{"location":"adapter/#the-igbinary-adapter","text":"Igbinary was originally released by Sulake Dynamoid Oy and since 2011-03-14 moved to PECL and maintained by Pierre Joye. It's a drop-in replacement for the standard PHP serializer. Instead of using a costly textual representation, igbinary stores PHP data structures in a compact binary form. Savings are significant when using memcached or similar memory based storages for serialized data. You need the igbinary PHP extension installed on your system in order to use this adapter. There are no configurable options for this adapter.","title":"The IgBinary Adapter"},{"location":"adapter/#the-wddx-adapter","text":"WDDX (Web Distributed Data eXchange) is a programming-language-, platform-, and transport-neutral data interchange mechanism for passing data between different environments and different computers. The adapter uses the wddx PHP functions. Please read the PHP manual to determine how you may enable them in your installation. Additionally, the SimpleXML extension is used to check if a returned NULL value from wddx_unserialize() is based on a serialized NULL or on invalid data. Available options include: Option Data Type Default Value Description comment string An optional comment that appears in the packet header.","title":"The Wddx Adapter"},{"location":"adapter/#the-json-adapter","text":"The JSON adapter provides a bridge to the zend-json component. Available options include: Option Data Type Default Value cycle_check boolean false object_decode_type Zend\\Json\\Json::TYPE_* Zend\\Json\\Json::TYPE_ARRAY enable_json_expr_finder boolean false","title":"The Json Adapter"},{"location":"adapter/#the-pythonpickle-adapter","text":"This adapter converts PHP types to a Python Pickle string representation. With it, you can read the serialized data with Python and read Pickled data from Python with PHP. This adapter requires the zend-math component: $ composer require zendframework/zend-math Available options include: Option Data Type Default Value Description protocol integer (0/1/2/3) 0 The Pickle protocol version used on serialize","title":"The PythonPickle Adapter"},{"location":"adapter/#datatype-merging-php-to-python-pickle","text":"PHP Type Python Pickle Type NULL None boolean boolean integer integer float float string string array list list array map dictionary object dictionary","title":"Datatype merging (PHP to Python Pickle)"},{"location":"adapter/#datatype-merging-python-pickle-to-php","text":"Python Pickle Type PHP Type None NULL boolean boolean integer integer long integer , float , string , or Zend\\Serializer\\Exception\\ExceptionInterface float float string string bytes string unicode string string UTF-8 list array list tuple array list dictionary array map All other types Zend\\Serializer\\Exception\\ExceptionInterface","title":"Datatype merging (Python Pickle to PHP)"},{"location":"adapter/#the-phpcode-adapter","text":"The Zend\\Serializer\\Adapter\\PhpCode adapter generates a parsable PHP code representation using var_export() . To restore, the data will be executed using eval . There are no configuration options for this adapter.","title":"The PhpCode Adapter"},{"location":"adapter/#warning-unserializing-objects","text":"Objects will be serialized using the __set_state magic method. If the class doesn't implement this method, a fatal error will occur during execution.","title":"Warning: Unserializing objects"},{"location":"adapter/#warning-uses-eval","text":"The PhpCode adapter utilizes eval() to unserialize. This introduces both a performance and potential security issue as a new process will be executed. Typically, you should use the PhpSerialize adapter unless you require human-readability of the serialized data.","title":"Warning: Uses eval()"},{"location":"intro/","text":"Introduction zend-serialzier provides an adapter-based interface for serializing and deserializing PHP types to and from different representations. For more information what a serializer is read the wikipedia page of Serialization . Quick Start Serializing adapters can either be created from the provided Zend\\Serializer\\Serializer::factory method, or by instantiating one of the Zend\\Serializer\\Adapter\\* classes. use Zend\\Serializer\\Adapter; use Zend\\Serializer\\Exception; use Zend\\Serializer\\Serializer; // Via factory: $serializer = Serializer::factory(Adapter\\PhpSerialize::class); // Alternately: $serializer = new Adapter\\PhpSerialize(); // Now $serializer is an instance of Zend\\Serializer\\Adapter\\AdapterInterface, // specifically Zend\\Serializer\\Adapter\\PhpSerialize try { $serialized = $serializer->serialize($data); // now $serialized is a string $unserialized = $serializer->unserialize($serialized); // now $data == $unserialized } catch (Exception\\ExceptionInterface $e) { echo $e; } The method serialize() generates a storable string. To regenerate this serialized data, call the method unserialize() . Any time an error is encountered serializing or unserializing, the adapter will throw a Zend\\Serializer\\Exception\\ExceptionInterface . Because an application often uses only one serializer internally, it is possible to define and use a default serializer. That serializer will be used by default by other components like Zend\\Cache\\Storage\\Plugin\\Serializer . To define and use the default serializer, use the static serialization methods of the basic Zend\\Serializer\\Serializer : use Zend\\Serializer\\Adapter; use Zend\\Serializer\\Exception; use Zend\\Serializer\\Serializer; Serializer::setDefaultAdapter(Adapter\\PhpSerialize::class); try { $serialized = Serializer::serialize($data); // now $serialized is a string $unserialized = Serializer::unserialize($serialized); // now $data == $unserialized } catch (Exception\\ExceptionInterface $e) { echo $e; } Basic configuration Options To configure a serializer adapter, you can optionally use an instance of Zend\\Serializer\\Adapter\\AdapterOptions , an instance of one of the adapter specific options class, an array , or a Traversable object. The adapter will convert it into the adapter specific options class instance (if present) or into the basic Zend\\Serializer\\Adapter\\AdapterOptions class instance. Options can be passed as the second argument to the provided Zend\\Serializer\\Serializer::factory and ::setDefaultAdapter methods, via the adapter's setOptions method, or as constructor arguments when directly instantiating an adapter. Available Methods Each serializer implements the interface Zend\\Serializer\\Adapter\\AdapterInterface . This interface defines the following methods: Method signature Description serialize(mixed $value) : string Generates a storable representation of a value. unserialize(string $value) : mixed Creates a PHP value from a stored representation. The base class Zend\\Serializer\\Serializer is used to instantiate the adapters, to configure the factory, and as a proxy for serialization operations. It defines the following static methods, where the following references map to classes/interfaces as follows: AdapterPluginManager : Zend\\Serializer\\AdapterPluginManager AdapterInterface : Zend\\Serializer\\Adapter\\AdapterInterface AdapterOptions : Zend\\Serializer\\Adapter\\AdapterOptions Method signature Description factory(/* ... */) : AdapterInterface Create a serializer adapter instance. Arguments are: string|AdapterInterface $adapterName, AdapterOptions|array|Traversable $adapterOptions = null . setAdapterPluginManager(AdapterPluginManager $adapters) : void Change the adapter plugin manager. getAdapterPluginManager() : AdapterPluginManager Get the adapter plugin manager. resetAdapterPluginManager() : void Resets the internal adapter plugin manager. setDefaultAdapter(string|AdapterInterface $adapter /* ... */) : void Change the default adapter. Full argument list: string|AdapterInterface $adapter, AdapterOptions|array|Traversable $adapterOptions = null . getDefaultAdapter() : AdapterInterface Get the default adapter. serialize(mixed $data /* ... */) : string Generates a storable representation of a value using the default adapter. Optionally, provide a different adapter via the second argument. Full argument list: mixed $value, string|AdapterInterface $adapter = null, AdapterOptions|array|Traversable $adapterOptions = null . unserialize(string $value /* ... */) : mixed Creates a PHP value from a stored representation using the default adapter. Optionally, provide a different adapter via the second argument. Full argument list: string $value, string|AdapterInterface|null $adapter = null, AdapterOptions|array|Traversable $adapterOptions = null","title":"Intro"},{"location":"intro/#introduction","text":"zend-serialzier provides an adapter-based interface for serializing and deserializing PHP types to and from different representations. For more information what a serializer is read the wikipedia page of Serialization .","title":"Introduction"},{"location":"intro/#quick-start","text":"Serializing adapters can either be created from the provided Zend\\Serializer\\Serializer::factory method, or by instantiating one of the Zend\\Serializer\\Adapter\\* classes. use Zend\\Serializer\\Adapter; use Zend\\Serializer\\Exception; use Zend\\Serializer\\Serializer; // Via factory: $serializer = Serializer::factory(Adapter\\PhpSerialize::class); // Alternately: $serializer = new Adapter\\PhpSerialize(); // Now $serializer is an instance of Zend\\Serializer\\Adapter\\AdapterInterface, // specifically Zend\\Serializer\\Adapter\\PhpSerialize try { $serialized = $serializer->serialize($data); // now $serialized is a string $unserialized = $serializer->unserialize($serialized); // now $data == $unserialized } catch (Exception\\ExceptionInterface $e) { echo $e; } The method serialize() generates a storable string. To regenerate this serialized data, call the method unserialize() . Any time an error is encountered serializing or unserializing, the adapter will throw a Zend\\Serializer\\Exception\\ExceptionInterface . Because an application often uses only one serializer internally, it is possible to define and use a default serializer. That serializer will be used by default by other components like Zend\\Cache\\Storage\\Plugin\\Serializer . To define and use the default serializer, use the static serialization methods of the basic Zend\\Serializer\\Serializer : use Zend\\Serializer\\Adapter; use Zend\\Serializer\\Exception; use Zend\\Serializer\\Serializer; Serializer::setDefaultAdapter(Adapter\\PhpSerialize::class); try { $serialized = Serializer::serialize($data); // now $serialized is a string $unserialized = Serializer::unserialize($serialized); // now $data == $unserialized } catch (Exception\\ExceptionInterface $e) { echo $e; }","title":"Quick Start"},{"location":"intro/#basic-configuration-options","text":"To configure a serializer adapter, you can optionally use an instance of Zend\\Serializer\\Adapter\\AdapterOptions , an instance of one of the adapter specific options class, an array , or a Traversable object. The adapter will convert it into the adapter specific options class instance (if present) or into the basic Zend\\Serializer\\Adapter\\AdapterOptions class instance. Options can be passed as the second argument to the provided Zend\\Serializer\\Serializer::factory and ::setDefaultAdapter methods, via the adapter's setOptions method, or as constructor arguments when directly instantiating an adapter.","title":"Basic configuration Options"},{"location":"intro/#available-methods","text":"Each serializer implements the interface Zend\\Serializer\\Adapter\\AdapterInterface . This interface defines the following methods: Method signature Description serialize(mixed $value) : string Generates a storable representation of a value. unserialize(string $value) : mixed Creates a PHP value from a stored representation. The base class Zend\\Serializer\\Serializer is used to instantiate the adapters, to configure the factory, and as a proxy for serialization operations. It defines the following static methods, where the following references map to classes/interfaces as follows: AdapterPluginManager : Zend\\Serializer\\AdapterPluginManager AdapterInterface : Zend\\Serializer\\Adapter\\AdapterInterface AdapterOptions : Zend\\Serializer\\Adapter\\AdapterOptions Method signature Description factory(/* ... */) : AdapterInterface Create a serializer adapter instance. Arguments are: string|AdapterInterface $adapterName, AdapterOptions|array|Traversable $adapterOptions = null . setAdapterPluginManager(AdapterPluginManager $adapters) : void Change the adapter plugin manager. getAdapterPluginManager() : AdapterPluginManager Get the adapter plugin manager. resetAdapterPluginManager() : void Resets the internal adapter plugin manager. setDefaultAdapter(string|AdapterInterface $adapter /* ... */) : void Change the default adapter. Full argument list: string|AdapterInterface $adapter, AdapterOptions|array|Traversable $adapterOptions = null . getDefaultAdapter() : AdapterInterface Get the default adapter. serialize(mixed $data /* ... */) : string Generates a storable representation of a value using the default adapter. Optionally, provide a different adapter via the second argument. Full argument list: mixed $value, string|AdapterInterface $adapter = null, AdapterOptions|array|Traversable $adapterOptions = null . unserialize(string $value /* ... */) : mixed Creates a PHP value from a stored representation using the default adapter. Optionally, provide a different adapter via the second argument. Full argument list: string $value, string|AdapterInterface|null $adapter = null, AdapterOptions|array|Traversable $adapterOptions = null","title":"Available Methods"}]}